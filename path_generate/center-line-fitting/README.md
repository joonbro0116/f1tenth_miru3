# Center-Line Fitting with GUI

SLAM을 통해 생성된 트랙 이미지에서 중심선을 추출하여 CSV 파일로 출력하는 도구입니다.
사용자 친화적인 GUI 인터페이스로 파라미터를 쉽게 조정할 수 있습니다!

## 🆕 주요 기능

- **파라미터화된 디노이징**: DBSCAN 기반 노이즈 제거 파라미터 실시간 조정
- **다양한 스무딩 방법**: 곡률 기반, 가우시안, 스플라인 보간 등 선택 가능
- **직관적인 GUI**: 슬라이더와 직접 입력 칸으로 정밀한 파라미터 설정
- **설정 저장/로드**: JSON 형식으로 설정을 저장하고 재사용
- **실시간 진행률**: 처리 과정의 진행 상황 실시간 확인
- **PGM 오버레이 시각화**: PGM 이미지 위에 centerline을 오버레이하여 결과 확인
- **결과 비교**: 원본과 스무딩된 centerline 비교 차트

## 설치 및 사용

### 필수 패키지
```bash
pip install matplotlib numpy scikit-learn scikit-image scipy pyyaml
sudo apt-get install python3-tk  # Ubuntu/Debian
```

### GUI 실행
```bash
cd /home/ojg/sim_ws/path_generate/center-line-fitting
python3 centerline_gui.py
```

## 📋 파라미터 상세 설명

### 🗂️ 파일 설정
- **PGM 트랙 이미지**: 흑백으로 된 트랙 맵 이미지 파일 (.pgm)
- **YAML 정보 파일**: 해상도(resolution), 원점(origin) 등 좌표 변환 정보
- **출력 디렉토리**: 결과 CSV 파일이 저장될 폴더

### 🧹 디노이징 파라미터 (DBSCAN 클러스터링)

**DBSCAN 반지름 (eps)**: `0.5 ~ 5.0` (기본값: 2.0)
- **역할**: 두 픽셀이 "같은 클러스터"에 속하려면 얼마나 가까워야 하는지 정의
- **단위**: 픽셀 거리 (유클리드 거리)
- **작게 하면**: 더 엄격한 기준 → 작은 노이즈까지 제거하지만 트랙 일부 손실 가능
- **크게 하면**: 관대한 기준 → 트랙은 잘 보존되지만 노이즈가 남을 수 있음
- **실제 효과**: PGM 이미지에서 흩어진 픽셀들을 하나의 연결된 트랙으로 그룹화

**최소 샘플 비율**: `2.0 ~ 20.0` (기본값: 8.0)
- **역할**: 하나의 "핵심 포인트"가 되려면 주변에 몇 개의 다른 포인트가 있어야 하는지
- **계산**: `min_samples = max(2, int(total_pixels / 이 값))`
- **작게 하면**: 적은 주변 포인트로도 핵심 포인트 인정 → 노이즈도 클러스터가 될 수 있음
- **크게 하면**: 많은 주변 포인트가 있어야 핵심 포인트 → 확실한 트랙 부분만 남음

**최소 클러스터 비율**: `0.001 ~ 0.1` (기본값: 0.01)
- **역할**: 전체 픽셀 수 대비 몇 퍼센트 이상의 클러스터만 유지할지
- **계산**: `min_cluster_size = max(이 값 * total_pixels, 최소값)`
- **작게 하면**: 작은 클러스터도 유지 → 트랙의 작은 부분도 보존
- **크게 하면**: 큰 클러스터만 유지 → 확실한 주요 트랙만 남김

**최소 클러스터 최소값**: `5 ~ 50` (기본값: 10)
- **역할**: 클러스터 크기의 절대적 하한선 (픽셀 개수)
- **효과**: 비율 계산 결과가 너무 작아도 최소 이만큼은 보장

### 🎨 스무딩 파라미터

#### 스무딩 방법별 동작 원리

**curvature** (곡률 기반 선택적 스무딩)
- **동작**: 각 포인트의 곡률(curvature)을 계산하고, 임계값 이상인 포인트만 스무딩
- **곡률 계산**: 3점을 이용한 원의 곡률 공식 사용
- **장점**: 직선 구간은 그대로 유지, 급커브만 부드럽게
- **사용 시기**: 레이싱 트랙처럼 직선과 커브가 명확히 구분되는 경우

**gaussian** (가우시안 필터)
- **동작**: 각 포인트를 가우시안 가중평균으로 주변 포인트들과 블렌딩
- **수식**: `new_point = Σ(weight_i * point_i)`, weight는 가우시안 분포
- **장점**: 전체적으로 매끄러운 곡선
- **사용 시기**: 전반적으로 부드러운 트랙을 원할 때

**spline** (B-스플라인 보간)
- **동작**: 기존 포인트들을 제어점으로 하는 B-스플라인 곡선 생성
- **특징**: 포인트 수를 `spline_points_ratio`배로 증가시킴
- **장점**: 매우 매끄럽고 수학적으로 연속적인 곡선
- **사용 시기**: 포인트 밀도를 높이면서 매끄러운 곡선을 원할 때

#### Curvature 방법 세부 파라미터

**곡률 임계값**: `0.1 ~ 1.0` (기본값: 0.3)
- **역할**: 이 값 이상의 곡률을 가진 포인트만 스무딩 대상으로 선정
- **곡률 의미**: 1/반지름 (단위: 1/미터). 값이 클수록 더 급한 커브
- **계산 예시**: 
  - 반지름 10m 커브 = 곡률 0.1
  - 반지름 3m 커브 = 곡률 0.33
  - 반지름 1m 커브 = 곡률 1.0
- **작게 하면**: 완만한 커브도 스무딩 → 더 부드러운 전체 결과
- **크게 하면**: 급격한 헤어핀만 스무딩 → 원본 형태 최대한 유지

**윈도우 크기**: `20 ~ 100` (기본값: 60)
- **역할**: 한 포인트를 스무딩할 때 앞뒤로 몇 개의 포인트를 참고할지
- **동작**: 현재 포인트 ± (윈도우크기/2) 범위의 포인트들로 가중평균 계산
- **예시**: 윈도우 60 = 현재 포인트 앞뒤로 30개씩, 총 61개 포인트 사용
- **작게 하면**: 
  - 국소적 스무딩 → 세밀한 변화 보존
  - 빠른 처리 속도
  - 급격한 변화에 민감하게 반응
- **크게 하면**:
  - 전역적 스무딩 → 더 부드럽고 일관된 곡선
  - 느린 처리 속도  
  - 장거리에 걸친 경향을 반영

**반복 횟수**: `1 ~ 10` (기본값: 5)
- **역할**: 스무딩 과정을 몇 번 반복할지 (iterative smoothing)
- **동작**: 매 반복마다 이전 결과에 다시 스무딩 적용
- **수렴**: 보통 5-7회 후 변화량이 매우 작아짐
- **적게 하면**: 빠른 처리, 원본에 가까운 결과
- **많이 하면**: 더 부드럽지만 원본에서 멀어질 수 있음

**혼합 계수 (블렌드 팩터)**: `0.1 ~ 0.9` (기본값: 0.3)
- **역할**: 원본 포인트와 스무딩된 포인트를 섞는 비율
- **수식**: `result = (1-α) * original + α * smoothed`
- **예시**: 0.3 = 원본 70% + 스무딩 30%
- **작게 하면**: 보수적 스무딩 → 원본 형태 최대한 보존
- **크게 하면**: 적극적 스무딩 → 스무딩 효과 강화

#### Gaussian 방법 파라미터

**가우시안 시그마**: `1.0 ~ 5.0` (기본값: 2.0)
- **역할**: 가우시안 분포의 표준편차 (σ)
- **가중치 계산**: `weight = exp(-distance²/(2σ²))`
- **물리적 의미**: 시그마의 3배 거리까지 99.7%의 영향력
- **예시**: σ=2.0이면 6픽셀 거리까지 영향
- **작게 하면**: 좁은 범위만 고려 → 약한 스무딩, 세밀함 유지
- **크게 하면**: 넓은 범위 고려 → 강한 스무딩, 매우 부드러운 곡선

#### Spline 방법 파라미터

**스플라인 포인트 비율**: `1.0 ~ 10.0` (기본값: 1.0)
- **역할**: 원본 대비 몇 배의 포인트를 생성할지
- **동작**: 기존 포인트 사이에 새로운 포인트들을 B-spline 곡선 상에 생성
- **예시**: 
  - 1.0 = 원본과 동일 (1000개 → 1000개)
  - 2.0 = 2배 증가 (1000개 → 2000개)
  - 4.0 = 4배 증가 (1000개 → 4000개)
- **주의**: curvature 방법에서는 이 파라미터가 무시됩니다!

### ⚙️ 기본 처리 파라미터

**서브샘플링 주기**: `1 ~ 5` (기본값: 1)
- **역할**: 최종 centerline에서 몇 번째마다 포인트를 선택할지
- **동작**: `if (index % period == 0)` 조건으로 포인트 선택
- **포인트 밀도**:
  - 1 = 모든 포인트 (100%)
  - 2 = 절반 포인트 (50%)  
  - 3 = 1/3 포인트 (33%)
  - 5 = 1/5 포인트 (20%)
- **메모리/성능**: 값이 클수록 적은 포인트 → 빠른 처리, 적은 메모리

**플롯 모드**: `0, 1, 2` (기본값: 1)
- **0**: 플롯 없음 → 최고 속도, 백그라운드 처리용
- **1**: 기본 플롯 → 최종 결과만 시각화
- **2**: 전체 플롯 → 모든 처리 단계를 시각화 (디버깅용)

## 🔧 처리 과정 4단계

### 1. Denoise (디노이징)
- **목적**: 스캔 노이즈, 벽면 불규칙성 제거  
- **방법**: DBSCAN 클러스터링을 positive/negative space에 각각 적용
- **결과**: 연결된 메인 트랙만 남음

### 2. Skeletonize (스켈레톤화)
- **목적**: 트랙 폭을 1픽셀 두께의 중심선으로 변환
- **방법**: Zhang-Suen skeletonization 알고리즘
- **결과**: 트랙 중앙을 지나는 얇은 선

### 3. Prune and Order (가지치기 및 정렬)
- **목적**: 불필요한 가지 제거 + 순서대로 정렬
- **방법**: DFS로 가장 긴 사이클 탐색
- **결과**: 트랙을 한 바퀴 도는 순서대로 정렬된 포인트 리스트

### 4. Subsample (서브샘플링)  
- **목적**: 최종 포인트 밀도 조정
- **방법**: 지정된 주기로 포인트 선택
- **결과**: 원하는 밀도의 centerline 포인트

## 💡 상황별 추천 설정

### 🏁 일반적인 F1TENTH 트랙
```
디노이즈 반지름: 2.0          # 표준 노이즈 레벨
스무딩 방법: curvature         # 직선 보존 + 커브 스무딩  
곡률 임계값: 0.3               # 반지름 3m 이하 커브만 스무딩
윈도우 크기: 60                # 적당한 국소성
서브샘플링 주기: 1             # 최대 해상도
```

### 🌪️ 복잡한 트랙 (타이트한 헤어핀 많음)
```
디노이즈 반지름: 1.5          # 정밀한 노이즈 제거
곡률 임계값: 0.2               # 더 완만한 커브도 스무딩
윈도우 크기: 40                # 국소적 스무딩으로 세밀함 유지
반복 횟수: 3                   # 적은 반복으로 과스무딩 방지
```

### 🛣️ 단순한 고속 트랙 (완만한 커브)
```
디노이즈 반지름: 2.5          # 관대한 노이즈 처리
스무딩 방법: gaussian          # 전체적으로 부드럽게
가우시안 시그마: 3.0           # 강한 스무딩
서브샘플링 주기: 2             # 포인트 수 절약
```

### 🎯 고정밀도 매핑용
```
디노이즈 반지름: 2.0          
스무딩 방법: curvature
곡률 임계값: 0.15              # 매우 민감한 스무딩
윈도우 크기: 80                # 넓은 범위 고려
혼합 계수: 0.2                 # 보수적 스무딩
서브샘플링 주기: 1             # 모든 포인트 유지
```

## 🔧 문제 해결

### GUI 실행 안 됨
```bash
sudo apt-get install python3-tk
pip install --upgrade matplotlib numpy scikit-learn scikit-image scipy pyyaml
```

### Centerline이 끊어짐 
- **원인**: 디노이징이 너무 강함
- **해결**: 디노이즈 반지름 증가, 최소 샘플 비율 감소

### 결과가 너무 각짐
- **원인**: 스무딩이 부족함  
- **해결**: 곡률 임계값 감소, 반복 횟수 증가

### 직선 구간이 흔들림
- **원인**: 전역 스무딩의 부작용
- **해결**: curvature 방법 사용, 곡률 임계값 적절히 설정

### 메모리 부족
- **해결**: 서브샘플링 주기 증가, 플롯 모드 0으로 설정